---
number: 5
title: "Разбор пытанняў з рэальных сумоўяў JS Core - 3."
dateArticle: "02.02.2023"
author: "loveJS"
chapters: 1
layout: episode.njk
tags: episode
---

**Пытанне:**

Адкуль _метады_ ў прымітыўных тыпаў дадзеных? Што такое **_boxing_** і **_unboxing_**?

**Кароткі адказ**

У прымітыўных тыпаў дадзеных, акрамя `null` і `undefined`, есць метады, да якіх мы можам звярнуцца.

Метады возьмуцца з убудаванага _прататыпа канструктара_ адпаведнага тыпу. Невідавочна ствараецца абгортка з канструктара, выкарыстойваецца неабходны метад. Адразу пасля выкарыстоўвання абгортка выдаляецца.

Гэты працэс называецца адпаведна **_boxing_** і **_unboxing_**.

**Падрабязны адказ**

У прымітыўных тыпаў дадзеных, акрамя `null` і `undefined`, есць _метады_, да якіх мы можам звярнуцца.

Напрыклад:

> `'hello'.toUpperCase();`

Адкуль узяліся метады ў прымітыўных тыпаў дадзеных?

Для кожнага прымітыўнага тыпу дадзеных, акрамя `null` і `undefined`, існуе свой убудаваны канструктар, з якога і возьмуцца неабходныя метады.

Напрыклад, пры выкананні наступнага кода

> `const greeting = 'hello'.toUpperCase();`

`'hello'` абгорнецца "пад капотам" у

> `new String('hello').toUpperCase();`

Метад toUpperCase возьмецца з прататыпа каструктара `String`. Гэты працэс называецца **_boxing_**.

Такое абгортванне кода не азначае, што зараз наша прымітыўнае строкавае значэнне стала аб'ектам, бо адразу пасля выкарыстоўвання адбываецца адваротны працэсс распакоўкі аб'ектных тыпаў назад у прымітывы, які называецца **_unboxing_**.

> `const greeting = 'hello'.toUpperCase();`
>
> `console.log(typeof greeting);`
>
> `// string`

Увесь гэты працэс мае назву `auto boxing`.

Калі нам патрэбна відавочна прывесці адзін тып дадзеных да другога, можна выкарыстоўваць `канструктар` патрэбнага тыпу, але без `new`:

> `const number = Number("1");`
>
> `console.log(typeof number);`
>
> `// number`

Чаму непажадана відавочна выкарыстоўваць `new Number("1")`?

> `const number = new Number("1");`
>
> `console.log(number === 1);`
>
> `// false`
>
> `console.log(typeof number);`
>
> `// object`

Відавочнае абгортванне значэння называецца `manual autoboxing`.
